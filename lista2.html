<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
  <title>Lista de Presen√ßa - V√¥lei BNH</title>
  <link rel="icon" type="image/png" sizes="16x16" href="windows11/Square44x44Logo.altform-unplated_targetsize-16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="windows11/Square44x44Logo.altform-unplated_targetsize-32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="android/android-launchericon-192-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="android/android-launchericon-512-512.png">
  <link rel="apple-touch-icon" href="ios/192.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://moment.github.io/luxon/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <link rel="stylesheet" href="lista.css?v=2.2">
  <style>
    /* Estilos anteriores mantidos */
  </style>
</head>
<body>
  <!-- HTML anterior mantido -->
  <div class="header">
    <button class="menu-toggle" id="menuToggle" style="font-size: 11px;">
      <i class="fas fa-bars" style="font-size: 20px;"></i><br><strong>Menu</strong>
    </button>
    <center><h2><i class="fas fa-volleyball-ball"></i> V√¥lei-BNH</h2></center>
  </div>
  <div class="sidebar" id="sidebar">
    <div class="sidebar-menu">
      <div class="user-profile">
        <img id="sidebarUserPhoto" class="sidebar-user-photo" src="" alt="Foto do usu√°rio">
        <div class="sidebar-user-info">
          <div id="sidebarUserName" class="sidebar-user-name"></div>
          <div id="sidebarUserPosition" class="sidebar-user-position"></div>
          <div id="userEmail" class="sidebar-user-position"></div>
        </div>
      </div>
      <button id="transparenciaBtn" class="logout-btn" onclick="window.location.href='transparencia.html'"><i class="fas fa-hand-holding-usd"></i> Transpar√™ncia
      </button>
      <button class="logout-btn" onclick="window.location.href='enquete.html'"><i class="fas fa-question-circle"></i> Enquetes
      </button>
      <button id="listaBtn" class="logout-btn" onclick="window.location.href='lista.html'"><i class="fas fa-list"></i> Jogos</button>
    </div>
    <button id="logoutBtn" class="logout-btn"><i class="fas fa-sign-out-alt"></i> Sair</button>
  </div>
  <div class="overlay" id="overlay"></div>
  <div class="container">
    <div id="game-list" class="tab-content active">
      <div id="content" class="section">
        <div class="section-title">
          <h2><i class="fas fa-volleyball-ball"></i> Jogos Programados </h2>
          <button id="adminSettingsBtn" style="display: none;" class="settings-btn"><i class="fas fa-cog"></i> Abrir Lista / Configurar</button>
        </div>
        <div class="game-selector">
          <h3>Selecione um Jogo</h3>
          <select id="gameSelect" class="game-select"></select>
        </div>
        <div class="game-list">
          <h3>Lista do Dia: 
            <span class="lampada" onclick="mostrarPopup('meupopup1')">‚ÑπÔ∏è</span>    
          </h3>
          <div class="game-info">
            <span id="gameDate"></span> - <span id="gameTime"></span>
          </div>
          <div id="confirmedPlayers"></div>
        </div>
        <div class="waitlist">
          <h3>Lista de Espera:
            <span class="lampada" onclick="mostrarPopup('meupopup2')">‚ÑπÔ∏è</span> 
          </h3>
          <div id="waitlistPlayers"></div>
        </div>
        <div class="game-controls">
          <div class="guest-controls">
            <button id="confirmPlayer" style="display: none;"><i class="fas fa-sign-in"></i> Entrar em Quadra</button>          
          </div>
          <div class="guest-controls" id="guestControls" style="display: none;">
            <button id="convidadobtn"><i class="fa-regular fa-clock"></i> Convidados ap√≥s 16:00 </button>
            <input type="text" id="guestNameInput" placeholder="Nome do Convidado" maxlength="15">
            <button id="addGuestBtn"><i class="fas fa-user-plus"></i> Adicionar Convidado</button>
          </div>
          <div class="guest-controls" id="adminSearchContainer" style="display: none;">
            <input type="text" id="playerSearch" placeholder="Pesquisar jogador por nome">
            <div class="autocomplete-suggestions" id="autocompleteSuggestions"></div>
            <button id="addPlayerBtn" disabled><i class="fas fa-plus"></i> Adicionar Jogador</button>
          </div>
          <button id="finalizeGameBtn" style="display: none;" class="finalize-btn"><i class="fas fa-save"></i> Finalizar Lista</button>
        </div>
      </div>
    </div>
    <div id="meupopup1" class="popup">
      ‚ÑπÔ∏è
      <p>A lista √© preenchida de acordo com a seguinte hierarquia: Mensal, Di√°ria e Convidado. Dentro de cada categoria, a ordem √© definida pelo momento da confirma√ß√£o. üòä</p>
      <button onclick="fecharPopup('meupopup1')">Fechar</button>
    </div>
    <div id="meupopup2" class="popup">
      ‚ÑπÔ∏è
      <p>A lista de espera √© preenchida quando o limite de participantes √© atingido, seguindo a mesma hierarquia. Caso um integrante saia da <strong>Lista do Dia</strong>, o primeiro da <strong>Lista de Espera</strong> sobe automaticamente. üòä</p>
      <button onclick="fecharPopup('meupopup2')">Fechar</button>
    </div>
  </div>
  <footer class="footer">
    ¬© 2025 SMV Eletr√¥nica- Todos os direitos reservados<br>
    <div class="footer-links">
      Powered by:
      <a href="https://github.com/seu-usuario" target="_blank" class="github-link">
        <i class="fab fa-github"></i> GitHub
      </a>
      <a href="https://firebase.google.com/" target="_blank" class="firebase-link">
        <i class="fas fa-fire"></i> Firebase
      </a>
      <a href="https://onesignal.com/" target="_blank" class="onesignal-link">
        <img src="https://dashboard.onesignal.com/favicon/favicon-32x32.png" alt="OneSignal" style="height:12px; vertical-align:middle; margin-right:4px;">
        OneSignal
      </a>
    </div>
  </footer>
  <script type="module" src="warnings.js"></script>
  <script type="module">
    import { handlePaymentWarnings, loadNotifiedPlayers, setupUnlockPlayerSearch, resetWarningsOnPaymentApproval } from './warnings.js';
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getDatabase, ref, get, set, onValue, push, update, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAWMgLaPMpNOdPW10S-bVVEiQW-r3QCkxg",
      authDomain: "volei-25301.firebaseapp.com",
      databaseURL: "https://volei-25301-default-rtdb.firebaseio.com",
      projectId: "volei-25301",
      storageBucket: "volei-25301.firebasestorage.app",
      messagingSenderId: "1007197261034",
      appId: "1:1007197261034:web:f2c7ab9cb2793a694cdb93",
      measurementId: "G-CYMLX0SJJQ"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const auth = getAuth(app);
    const { DateTime } = luxon;
    luxon.Settings.defaultLocale = 'pt-BR';
    const customWeekdays = {
      1: 'Segunda',
      2: 'Ter√ßa',
      3: 'Quarta',
      4: 'Quinta',
      5: 'Sexta',
      6: 'S√°bado',
      7: 'Domingo'
    };

    const contentDiv = document.getElementById('content');
    const confirmPlayerBtn = document.getElementById('confirmPlayer');
    const confirmedPlayersDiv = document.getElementById('confirmedPlayers');
    const waitlistPlayersDiv = document.getElementById('waitlistPlayers');
    const adminSearchContainer = document.getElementById('adminSearchContainer');
    const playerSearch = document.getElementById('playerSearch');
    const autocompleteSuggestions = document.getElementById('autocompleteSuggestions');
    const addPlayerBtn = document.getElementById('addPlayerBtn');
    const finalizeGameBtn = document.getElementById('finalizeGameBtn');
    const gameDateSpan = document.getElementById('gameDate');
    const gameTimeSpan = document.getElementById('gameTime');
    const guestControls = document.getElementById('guestControls');
    const guestNameInput = document.getElementById('guestNameInput');
    const addGuestBtn = document.getElementById('addGuestBtn');
    const adminSettingsBtn = document.getElementById('adminSettingsBtn');
    const menuToggle = document.getElementById('menuToggle');
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('overlay');

    let playerLimit = 16;
    let confirmedPlayers = [];
    let waitlistPlayers = [];
    window.currentUserPlayer = null;
    let emailLogado = null;
    let allPlayers = [];
    let selectedPlayerId = null;
    let currentGameDate = null;
    let guestFee = 5;
    let gameTime = "19:00";
    let isAdmin = false;
    let activeGames = [];
    let currentGameId = null;
    let currentGameData = null;

    // Fun√ß√£o para criar e inserir o bot√£o Dashboard
    function createDashboardButton() {
      const sidebarMenu = document.querySelector('.sidebar-menu');
      if (!sidebarMenu) {
        console.error("Elemento '.sidebar-menu' n√£o encontrado.");
        return;
      }
      const dashboardLink = document.createElement('div');
      dashboardLink.id = 'dashboardLink';
      dashboardLink.classList.add('sidebar-btn');
      dashboardLink.innerHTML = '<i class="fas fa-gear"></i> Administra√ß√£o';
      dashboardLink.addEventListener('click', () => {
        window.location.href = 'dashboard.html';
      });
      const transparenciaBtn = document.getElementById('transparenciaBtn');
      if (transparenciaBtn) {
        sidebarMenu.insertBefore(dashboardLink, transparenciaBtn);
      } else {
        sidebarMenu.appendChild(dashboardLink);
      }
    }

    // Fun√ß√£o para abrir/fechar o menu lateral
    function toggleSidebar() {
      sidebar.classList.toggle('active');
      overlay.classList.toggle('active');
    }

    menuToggle.addEventListener('click', toggleSidebar);
    overlay.addEventListener('click', toggleSidebar);

    const adminEmails = ['mvvasques@msn.com', 'fabioluiztx@outlook.com', 'evandroAsyncronousFunctionCall@msn.com'];
    const categoryPriority = {
      'MENSAL': 3,
      'DIARIA': 2,
      'CONVIDADO': 1
    };
    const defaultImage = 'https://firebasestorage.googleapis.com/v0/b/volei-25301.firebasestorage.app/o/players%2Fvisitante161.jpeg?alt=media&token=ed313e05-297e-4fe1-bdd6-699424719a7f';

    function formatDateToISO(date) {
      return DateTime.fromJSDate(date, { zone: 'America/Sao_Paulo' }).toISODate();
    }

    function formatDateToBR(dateStr) {
      return DateTime.fromISO(dateStr, { zone: 'America/Sao_Paulo' }).toFormat('dd/MM/yyyy');
    }

    function getBrazilTimestamp() {
      return DateTime.now().setZone('America/Sao_Paulo').toMillis();
    }

    function getBrazilDateTimeISO() {
      return DateTime.now().setZone('America/Sao_Paulo').toISO();
    }

    function getBrazilMonthYear() {
      return DateTime.now().setZone('America/Sao_Paulo').toFormat('yyyy-MM');
    }

    function updateGameDateDisplay() {
      if (currentGameData) {
        const gameDateTime = DateTime.fromISO(currentGameData.date, { zone: 'America/Sao_Paulo' });
        const formattedDate = formatDateToBR(currentGameData.date);
        const dayNumber = gameDateTime.weekday;
        const dayOfWeek = customWeekdays[dayNumber] || gameDateTime.toFormat('EEEE');
        gameDateSpan.textContent = `${formattedDate} (${dayOfWeek})`;
        gameTimeSpan.textContent = currentGameData.time;
      } else {
        const today = DateTime.now().setZone('America/Sao_Paulo');
        const formattedDate = formatDateToBR(formatDateToISO(new Date()));
        const dayNumber = today.weekday;
        const dayOfWeek = customWeekdays[dayNumber] || today.toFormat('EEEE');
        gameDateSpan.textContent = `${formattedDate} (${dayOfWeek})`;
        gameTimeSpan.textContent = gameTime;
      }
    }

    function sortPlayers(players) {
      return players.sort((a, b) => {
        const priorityA = categoryPriority[a.category] || 0;
        const priorityB = categoryPriority[b.category] || 0;
        if (priorityA !== priorityB) return priorityB - priorityA;
        return a.timestamp - b.timestamp;
      });
    }

    onAuthStateChanged(auth, async (user) => {
      console.log('onAuthStateChanged disparado, usu√°rio:', user);
      if (!user) {
        await Swal.fire({
          icon: 'error',
          title: 'Acesso Negado',
          text: 'Voc√™ precisa estar logado para acessar esta p√°gina.',
        });
        window.location.href = 'loginvl.html';
      } else {
        emailLogado = user.email;
        isAdmin = adminEmails.includes(emailLogado);
        await loadCurrentUserPlayer();
        if (window.currentUserPlayer?.name) {
          const userId = window.currentUserPlayer.id;
          const userName = window.currentUserPlayer.name;
          const [year, month] = getBrazilMonthYear().split('-');
          const now = DateTime.now().setZone('America/Sao_Paulo');
          const tenMinutesAgo = now.minus({ minutes: 10 });
          const lastAccessKey = `lastAccess_${userId}`;
          const lastAccess = localStorage.getItem(lastAccessKey);
          if (lastAccess && DateTime.fromISO(lastAccess) >= tenMinutesAgo) {
            console.log(`Acesso n√£o registrado: √∫ltimo acesso de ${userName} foi h√° menos de 10 minutos (localStorage).`);
          } else {
            const activitiesRef = ref(database, `userActivity/${year}/${month}`);
            try {
              const snapshot = await get(activitiesRef);
              let lastActivity = null;
              if (snapshot.exists()) {
                const activities = Object.values(snapshot.val() || {}).filter(
                  activity => activity.userName === userName
                );
                if (activities.length > 0) {
                  lastActivity = activities.reduce((latest, current) =>
                    new Date(current.timestamp) > new Date(latest.timestamp) ? current : latest
                  );
                }
              }
              if (!lastActivity || DateTime.fromISO(lastActivity.timestamp) < tenMinutesAgo) {
                const activityId = `activity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const activityRef = ref(database, `userActivity/${year}/${month}/${activityId}`);
                await set(activityRef, {
                  userName: userName,
                  timestamp: getBrazilDateTimeISO()
                });
                localStorage.setItem(lastAccessKey, now.toISO());
                console.log(`Acesso registrado para ${userName} em ${now.toISO()}`);
              } else {
                console.log(`Acesso n√£o registrado: √∫ltimo acesso de ${userName} foi h√° menos de 10 minutos.`);
              }
            } catch (error) {
              console.error('Erro ao registrar acesso:', error);
            }
          }
        }
        document.getElementById('userEmail').textContent = `${user.email}`;
        console.log('Usu√°rio logado:', emailLogado, 'isAdmin:', isAdmin);
        if (isAdmin) {
          createDashboardButton();
        }
        await loadGuestFee();
        await initializeGameList();
        setupAdminFeatures();
      }
    });

    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async () => {
        console.log('Bot√£o de logout clicado');
        Swal.fire({
          title: 'Saindo...',
          text: 'Por favor, aguarde.',
          allowOutsideClick: false,
          allowEscapeKey: false,
          didOpen: () => {
            Swal.showLoading();
          }
        });
        try {
          if (!auth) {
            console.error('Objeto auth n√£o est√° definido');
            await Swal.fire({
              icon: 'error',
              title: 'Erro',
              text: 'Erro interno de autentica√ß√£o.',
            });
            return;
          }
          await signOut(auth);
          console.log('Logout bem-sucedido');
          await Swal.fire({
            icon: 'success',
            title: 'Logout',
            text: 'Voc√™ saiu com sucesso.',
            timer: 1500,
            showConfirmButton: false,
          });
          window.location.assign('loginvl.html');
        } catch (error) {
          console.error('Erro ao fazer logout:', error);
          await Swal.fire({
            icon: 'error',
            title: 'Erro',
            text: 'N√£o foi poss√≠vel fazer logout. Tente novamente.',
          });
        }
      });
    } else {
      console.error('Elemento com ID "logoutBtn" n√£o encontrado');
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('VoleiBNHImages', 1);
        request.onupgradeneeded = event => {
          const db = event.target.result;
          db.createObjectStore('images', { keyPath: 'url' });
        };
        request.onsuccess = event => {
          resolve(event.target.result);
        };
        request.onerror = event => {
          reject(event.target.error);
        };
      });
    }

    async function saveImageToDB(url, blob) {
      try {
        const db = await openDB();
        const transaction = db.transaction(['images'], 'readwrite');
        const store = transaction.objectStore('images');
        store.put({ url, blob });
      } catch (error) {
        console.error('Erro ao salvar imagem no IndexedDB:', error);
      }
    }

    async function getImageFromDB(url) {
      try {
        const db = await openDB();
        const transaction = db.transaction(['images'], 'readonly');
        const store = transaction.objectStore('images');
        return new Promise((resolve, reject) => {
          const request = store.get(url);
          request.onsuccess = () => {
            resolve(request.result ? request.result.blob : null);
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      } catch (error) {
        console.error('Erro ao recuperar imagem do IndexedDB:', error);
        return null;
      }
    }

    async function preloadImage(imageUrl) {
      const cachedBlob = await getImageFromDB(imageUrl);
      if (cachedBlob) {
        return URL.createObjectURL(cachedBlob);
      }
      try {
        const response = await fetch(imageUrl);
        const blob = await response.blob();
        await saveImageToDB(imageUrl, blob);
        return URL.createObjectURL(blob);
      } catch (error) {
        console.warn(`Erro ao carregar imagem ${imageUrl}:`, error);
        return defaultImage;
      }
    }

    async function loadCurrentUserPlayer() {
      try {
        const playersRef = ref(database, 'players');
        const snapshot = await get(playersRef);
        if (snapshot.exists()) {
          allPlayers = Object.entries(snapshot.val()).map(([id, player]) => ({
            id,
            ...player
          }));
          window.currentUserPlayer = allPlayers.find(player => player.email === emailLogado);
          const sidebarUserPhoto = document.getElementById('sidebarUserPhoto');
          const sidebarUserName = document.getElementById('sidebarUserName');
          const sidebarUserPosition = document.getElementById('sidebarUserPosition');
          if (window.currentUserPlayer?.imageUrl) {
            sidebarUserPhoto.src = await preloadImage(window.currentUserPlayer.imageUrl);
            sidebarUserPhoto.style.display = 'block';
          } else {
            sidebarUserPhoto.src = defaultImage;
            sidebarUserPhoto.style.display = 'block';
          }
          sidebarUserName.textContent = window.currentUserPlayer?.name || 'Usu√°rio';
          sidebarUserPosition.textContent = window.currentUserPlayer?.position || 'Posi√ß√£o n√£o definida';
          await Promise.all(
            allPlayers
              .filter(player => player.imageUrl && player.imageUrl !== defaultImage)
              .map(player => preloadImage(player.imageUrl))
          );
          if (!window.currentUserPlayer) {
            await Swal.fire({
              icon: 'error',
              title: 'Erro',
              text: 'Nenhum jogador associado a este email. Contate o administrador.',
            });
            confirmPlayerBtn.disabled = true;
            guestControls.style.display = 'none';
          } else {
            confirmPlayerBtn.style.display = 'inline-block';
            guestControls.style.display = 'flex';
          }
          isAdmin = isAdmin || window.currentUserPlayer?.category === 'ADMIN';
          return window.currentUserPlayer;
        } else {
          await Swal.fire({
            icon: 'error',
            title: 'Erro',
            text: 'Nenhum jogador encontrado no sistema.',
          });
          confirmPlayerBtn.disabled = true;
          guestControls.style.display = 'none';
          return null;
        }
      } catch (error) {
        console.error('Erro ao carregar dados do jogador:', error);
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Erro ao carregar seus dados.',
        });
        confirmPlayerBtn.disabled = true;
        guestControls.style.display = 'none';
        return null;
      }
    }

    async function loadGuestFee() {
      try {
        const settingsRef = ref(database, 'settings/guestFee');
        const snapshot = await get(settingsRef);
        if (snapshot.exists()) {
          const value = parseFloat(snapshot.val());
          if (!isNaN(value) && value >= 0) {
            guestFee = value;
            console.log(`Taxa de convidado carregada: R$${guestFee}`);
          } else {
            console.warn(`Valor inv√°lido em settings/guestFee: ${snapshot.val()}. Usando padr√£o (5).`);
            guestFee = 5;
          }
        } else {
          console.log('N√≥ settings/guestFee n√£o existe. Usando padr√£o (5).');
          guestFee = 5;
        }
      } catch (error) {
        console.warn('Erro ao carregar taxa de convidado:', error.message);
        guestFee = 5;
        await Swal.fire({
          icon: 'warning',
          title: 'Aviso',
          text: 'Erro ao carregar taxa de convidado. Usando valor padr√£o (R$5).',
        });
      }
    }

    // Nova fun√ß√£o para verificar pend√™ncias e gerenciar avisos
    async function checkPendingPayments(playerId) {
      try {
        const paymentsRef = ref(database, 'payments');
        const snapshot = await get(paymentsRef);
        const payments = snapshot.val() || {};
        let pendingPayments = [];
        for (const year in payments) {
          for (const month in payments[year]) {
            const monthPayments = payments[year][month] || {};
            const playerPayments = Object.values(monthPayments).filter(
              p => (p.playerId === playerId || p.invitedById === playerId) && p.paymentStatus === 'inadimplente'
            );
            pendingPayments.push(...playerPayments.map(payment => ({
              ...payment,
              year,
              month
            })));
          }
        }
        return pendingPayments;
      } catch (error) {
        console.error('Erro ao verificar pend√™ncias de pagamento:', error);
        return [];
      }
    }

    // Nova fun√ß√£o para incrementar o contador de avisos
    async function incrementWarningCount(playerId) {
      try {
        const playerRef = ref(database, `players/${playerId}`);
        const snapshot = await get(playerRef);
        if (snapshot.exists()) {
          const playerData = snapshot.val();
          const currentWarnings = parseInt(playerData.warningCount) || 0;
          const newWarnings = currentWarnings + 1;
          await update(playerRef, { warningCount: newWarnings });
          return newWarnings;
        }
        return 0;
      } catch (error) {
        console.error('Erro ao incrementar contador de avisos:', error);
        return 0;
      }
    }

    // Nova fun√ß√£o para zerar o contador de avisos
    async function resetWarningCount(playerId) {
      try {
        const playerRef = ref(database, `players/${playerId}`);
        await update(playerRef, { warningCount: 0 });
        console.log(`Contador de avisos zerado para jogador ${playerId}`);
      } catch (error) {
        console.error('Erro ao zerar contador de avisos:', error);
      }
    }

    // Nova fun√ß√£o para obter o contador de avisos
    async function getWarningCount(playerId) {
      try {
        const playerRef = ref(database, `players/${playerId}`);
        const snapshot = await get(playerRef);
        if (snapshot.exists()) {
          return parseInt(snapshot.val().warningCount) || 0;
        }
        return 0;
      } catch (error) {
        console.error('Erro ao obter contador de avisos:', error);
        return 0;
      }
    }


async function setupAdminFeatures() {
  console.log('Iniciando setupAdminFeatures, isAdmin:', isAdmin);
  if (!adminSettingsBtn) {
    console.error('Elemento adminSettingsBtn n√£o encontrado no DOM');
    return;
  }
  if (isAdmin) {
    console.log('Configurando interface para admin');
    adminSettingsBtn.style.display = 'inline-block';
    adminSearchContainer.style.display = 'flex';
    finalizeGameBtn.style.display = 'inline-block';
    adminSettingsBtn.addEventListener('click', () => {
      console.log('Bot√£o adminSettingsBtn clicado');
      Swal.fire({
        title: 'Configurar Jogos',
        html: `
          <div class="organiza">
            <div class="modal-section">
              <label for="modalActionSelect">A√ß√£o:</label>
              <select id="modalActionSelect" class="game-select">
                <option value="createGame">Criar Novo Jogo</option>
                <option value="updateLimit">Alterar Participantes</option>
                <option value="updateFee">Alterar Taxa</option>
                <option value="updateTime">Alterar Hor√°rio</option>
                <option value="viewNotified">Ver Integrantes Notificados</option>
                <option value="unlockPlayer">Desbloquear Integrante</option>
              </select>
            </div>
            <div class="modal-section" id="gameSelectSection">
              <label for="modalGameSelect">Selecione um Jogo</label>
              <select id="modalGameSelect" class="game-select">
                <option value="">Selecione um jogo</option>
              </select>
            </div>
            <div id="createGameFields" class="modal-section" style="display: none;">
              <h4>Criar Novo Jogo</h4>
              <div class="organiza2">
                <label for="modalNewGameDate">Data:</label>
                <input type="date" id="modalNewGameDate">
              </div>
              <div class="organiza2">
                <label for="modalNewGameTime">Hor√°rio:</label>
                <input type="time" id="modalNewGameTime" value="19:00">
              </div>
              <div class="organiza2">
                <label for="modalNewGameLimit">N¬∫ de Participantes:</label>
                <input type="number" id="modalNewGameLimit" min="1" value="16">
                <button id="modalCreateGameBtn"><i class="fas fa-plus"></i> Criar Jogo</button>
              </div>
            </div>
            <div id="updateLimitFields" class="modal-section" style="display: none;">
              <h4>Alterar N√∫mero de Participantes</h4>
              <div class="organiza2">
                <label for="modalPlayerLimitInput">Participantes</label>
                <input type="number" id="modalPlayerLimitInput" value="${playerLimit}" pattern="[0-9]*">
                <button id="modalConfirmLimitBtn"><i class="fas fa-save"></i> Alterar</button>
              </div>
            </div>
            <div id="updateFeeFields" class="modal-section" style="display: none;">
              <h4>Alterar Taxa de Convidado</h4>
              <div class="organiza2">
                <label for="modalGuestFeeInput">Taxa (R$)</label>
                <input type="number" id="modalGuestFeeInput" step="0.01" min="0" value="${guestFee.toFixed(2)}">
                <button id="modalSaveGuestFeeBtn"><i class="fas fa-save"></i> Alterar</button>
              </div>
            </div>
            <div id="updateTimeFields" class="modal-section" style="display: none;">
              <h4>Alterar Hor√°rio do Jogo</h4>
              <div class="organiza2">
                <label for="modalGameTimeInput">Hor√°rio</label>
                <input type="time" id="modalGameTimeInput" value="${gameTime}">
                <button id="modalUpdateGameTimeBtn"><i class="fas fa-save"></i> Alterar</button>
              </div>
            </div>
            <div id="viewNotifiedFields" class="modal-section" style="display: none;">
              <h4>Integrantes Notificados</h4>
              <div id="notifiedPlayersList"></div>
            </div>
            <div id="unlockPlayerFields" class="modal-section" style="display: none;">
              <h4>Desbloquear Integrante</h4>
              <div class="organiza2">
                <input type="text" id="unlockPlayerSearch" placeholder="Pesquisar jogador por nome">
                <div class="autocomplete-suggestions" id="unlockAutocompleteSuggestions"></div>
                <button id="modalUnlockPlayerBtn" disabled><i class="fas fa-unlock"></i> Desbloquear</button>
              </div>
            </div>
          </div>
        `,
        showConfirmButton: false,
        showCancelButton: true,
        cancelButtonText: 'Cancelar',
        didOpen: async () => {
          console.log('Modal SweetAlert2 aberto');
          const modalGameSelect = document.getElementById('modalGameSelect');
          modalGameSelect.innerHTML = '<option value="">Selecione um jogo</option>';
          if (activeGames.length === 0) {
            modalGameSelect.innerHTML = '<option value="">Nenhum jogo agendado</option>';
          } else {
            activeGames.forEach(game => {
              const option = document.createElement('option');
              option.value = game.id;
              const gameDateTime = DateTime.fromISO(`${game.date}T${game.time}`, { zone: 'America/Sao_Paulo' });
              const formattedDate = gameDateTime.toFormat('dd/MM/yyyy');
              const formattedTime = gameDateTime.toFormat('HH:mm');
              const dayNumber = gameDateTime.weekday;
              const dayOfWeek = customWeekdays[dayNumber] || gameDateTime.toFormat('EEEE');
              option.textContent = `${formattedDate} - ${formattedTime} (${dayOfWeek})`;
              if (game.id === currentGameId) {
                option.selected = true;
              }
              modalGameSelect.appendChild(option);
            });
          }
          modalGameSelect.addEventListener('change', async () => {
            console.log('modalGameSelect alterado, novo valor:', modalGameSelect.value);
            currentGameId = modalGameSelect.value;
            await loadGameData(currentGameId);
            document.getElementById('gameSelect').value = currentGameId;
          });
          const modalActionSelect = document.getElementById('modalActionSelect');
          const createGameFields = document.getElementById('createGameFields');
          const updateLimitFields = document.getElementById('updateLimitFields');
          const updateFeeFields = document.getElementById('updateFeeFields');
          const updateTimeFields = document.getElementById('updateTimeFields');
          const viewNotifiedFields = document.getElementById('viewNotifiedFields');
          const unlockPlayerFields = document.getElementById('unlockPlayerFields');
          const gameSelectSection = document.getElementById('gameSelectSection');
          modalActionSelect.addEventListener('change', () => {
            createGameFields.style.display = modalActionSelect.value === 'createGame' ? 'block' : 'none';
            updateLimitFields.style.display = modalActionSelect.value === 'updateLimit' ? 'block' : 'none';
            updateFeeFields.style.display = modalActionSelect.value === 'updateFee' ? 'block' : 'none';
            updateTimeFields.style.display = modalActionSelect.value === 'updateTime' ? 'block' : 'none';
            viewNotifiedFields.style.display = modalActionSelect.value === 'viewNotified' ? 'block' : 'none';
            unlockPlayerFields.style.display = modalActionSelect.value === 'unlockPlayer' ? 'block' : 'none';
            gameSelectSection.style.display = ['createGame', 'viewNotified', 'unlockPlayer'].includes(modalActionSelect.value) ? 'none' : 'block';
            if (modalActionSelect.value === 'viewNotified') {
              loadNotifiedPlayers();
            }
            if (modalActionSelect.value === 'unlockPlayer') {
              setupUnlockPlayerSearch();
            }
          });
          modalActionSelect.value = 'createGame';
          createGameFields.style.display = 'block';
          gameSelectSection.style.display = 'none';
          const modalCreateGameBtn = document.getElementById('modalCreateGameBtn');
          modalCreateGameBtn.addEventListener('click', async () => {
            console.log('Bot√£o modalCreateGameBtn clicado');
            const newGameDateInput = document.getElementById('modalNewGameDate');
            const newGameTimeInput = document.getElementById('modalNewGameTime');
            const newGameLimitInput = document.getElementById('modalNewGameLimit');
            if (!newGameDateInput || !newGameTimeInput || !newGameLimitInput) {
              await Swal.fire({
                icon: 'error',
                title: 'Erro Interno',
                text: 'Campos do formul√°rio n√£o encontrados. Tente novamente.',
              });
              return;
            }
            const date = newGameDateInput.value;
            const time = newGameTimeInput.value;
            const limit = parseInt(newGameLimitInput.value);
            if (!date || !time || isNaN(limit) || limit < 1) {
              await Swal.fire({
                icon: 'error',
                title: 'Dados Inv√°lidos',
                text: 'Preencha todos os campos corretamente.',
              });
              return;
            }
            try {
              const gameId = `game_${Date.now()}`;
              const gameRef = ref(database, `activeGames/${gameId}`);
              await set(gameRef, {
                date,
                time,
                playerLimit: limit,
                confirmed: {},
                waitlist: {},
                createdAt: getBrazilDateTimeISO()
              });
              newGameDateInput.value = '';
              newGameTimeInput.value = '19:00';
              newGameLimitInput.value = '16';
              await Swal.fire({
                icon: 'success',
                title: 'Jogo Criado',
                text: 'Novo jogo criado com sucesso!',
              });
              const formattedDate = formatDateToBR(date);
              const message = `Novo jogo criado para ${formattedDate} √†s ${time}!`;
              await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage);
              await loadActiveGames();
              Swal.close();
            } catch (error) {
              console.error('Erro ao criar jogo:', error);
              await Swal.fire({
                icon: 'error',
                title: 'Erro',
                text: 'N√£o foi poss√≠vel criar o jogo.',
              });
            }
          });
          const modalConfirmLimitBtn = document.getElementById('modalConfirmLimitBtn');
          modalConfirmLimitBtn.addEventListener('click', async () => {
            console.log('Bot√£o modalConfirmLimitBtn clicado');
            const playerLimitInput = document.getElementById('modalPlayerLimitInput');
            const inputValue = playerLimitInput.value.trim();
            const newLimit = parseInt(inputValue);
            if (!Number.isInteger(newLimit) || isNaN(newLimit)) {
              await Swal.fire({
                icon: 'error',
                title: 'N√∫mero Inv√°lido',
                text: 'Por favor, insira um n√∫mero inteiro v√°lido.',
              });
              playerLimitInput.value = playerLimit;
              return;
            }
            if (newLimit < 1) {
              await Swal.fire({
                icon: 'error',
                title: 'Limite Inv√°lido',
                text: 'O limite deve ser pelo menos 1.',
              });
              playerLimitInput.value = playerLimit;
              return;
            }
            if (newLimit !== playerLimit) {
              playerLimit = newLimit;
              await adjustConfirmedPlayers();
              await updateFirebaseLists();
              updateGameList();
              updatePlayerLimitDisplay(isAdmin);
              const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
              const message = `Limite de participantes do jogo ${formattedDate} alterado para ${newLimit}.`;
              await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage);
              Swal.close();
            }
          });
          const modalSaveGuestFeeBtn = document.getElementById('modalSaveGuestFeeBtn');
          modalSaveGuestFeeBtn.addEventListener('click', async () => {
            console.log('Bot√£o modalSaveGuestFeeBtn clicado');
            const newFee = parseFloat(document.getElementById('modalGuestFeeInput').value);
            if (isNaN(newFee) || newFee < 0) {
              await Swal.fire({
                icon: 'error',
                title: 'Valor Inv√°lido',
                text: 'Por favor, insira um valor v√°lido.',
              });
              return;
            }
            try {
              await set(ref(database, 'settings/guestFee'), newFee);
              guestFee = newFee;
              await Swal.fire({
                icon: 'success',
                title: 'Sucesso',
                text: 'Taxa de convidado atualizada com sucesso.',
              });
              Swal.close();
            } catch (error) {
              console.error('Erro ao salvar taxa:', error);
              await Swal.fire({
                icon: 'error',
                title: 'Erro',
                text: 'Erro ao salvar taxa. Verifique suas permiss√µes.',
              });
            }
          });
          const modalUpdateGameTimeBtn = document.getElementById('modalUpdateGameTimeBtn');
          modalUpdateGameTimeBtn.addEventListener('click', async () => {
            console.log('Bot√£o modalUpdateGameTimeBtn clicado');
            if (!currentGameId) {
              await Swal.fire({
                icon: 'error',
                title: 'Nenhum Jogo Selecionado',
                text: 'Por favor, selecione um jogo para alterar o hor√°rio.',
              });
              return;
            }
            const newTime = document.getElementById('modalGameTimeInput').value;
            if (!newTime) {
              await Swal.fire({
                icon: 'error',
                title: 'Hor√°rio Inv√°lido',
                text: 'Por favor, selecione um hor√°rio v√°lido.',
              });
              return;
            }
            try {
              const gameRef = ref(database, `activeGames/${currentGameId}`);
              await set(gameRef, {
                ...currentGameData,
                time: newTime
              });
              currentGameData.time = newTime;
              gameTime = newTime;
              updateGameDateDisplay();
              await loadActiveGames();
              const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
              const message = `Hor√°rio do jogo ${formattedDate} alterado para ${newTime}.`;
              await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage);
              await Swal.fire({
                icon: 'success',
                title: 'Sucesso',
                text: 'Hor√°rio do jogo atualizado com sucesso.',
              });
              Swal.close();
            } catch (error) {
              console.error('Erro ao atualizar hor√°rio:', error);
              await Swal.fire({
                icon: 'error',
                title: 'Erro',
                text: 'Erro ao atualizar hor√°rio. Verifique suas permiss√µes.',
              });
            }
          });
        }
      });
    });
    setupPlayerSearch();
    setupGuestControls();
  } else {
    console.log('Configurando interface para n√£o-admin');
    adminSettingsBtn.style.display = 'none';
    adminSearchContainer.style.display = 'none';
    finalizeGameBtn.style.display = 'none';
    updatePlayerLimitDisplay(isAdmin);
  }
  guestControls.style.display = window.currentUserPlayer ? 'flex' : 'none';
}






 

    async function initializeGameList() {
      console.log('Iniciando initializeGameList');
      await loadActiveGames();
      finalizeGameBtn.addEventListener('click', async () => {
        console.log('Bot√£o finalizeGameBtn clicado');
        if (!currentGameId) {
          await Swal.fire({
            icon: 'error',
            title: 'Erro',
            text: 'Selecione um jogo ativo para finalizar.',
          });
          return;
        }
        try {
          const gameRef = ref(database, `activeGames/${currentGameId}`);
          const snapshot = await get(gameRef);
          if (!snapshot.exists()) {
            await Swal.fire({
              icon: 'error',
              title: 'Jogo N√£o Encontrado',
              text: 'O jogo selecionado n√£o foi encontrado.',
            });
            return;
          }
          await set(gameRef, null);
          const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
          const message = `Lista do jogo ${formattedDate} √†s ${currentGameData?.time || 'hor√°rio n√£o definido'} finalizada.`;
          await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage);
          await Swal.fire({
            icon: 'success',
            title: 'Lista Finalizada',
            text: 'A Lista foi Finalizada.',
          });
          currentGameId = null;
          await loadActiveGames();
        } catch (error) {
          console.error('Erro ao finalizar jogo:', error);
          await Swal.fire({
            icon: 'error',
            title: 'Erro',
            text: 'N√£o foi poss√≠vel finalizar o jogo.',
          });
        }
      });
      confirmPlayerBtn.addEventListener('click', () => abrirQuadra());
      setupGuestControls();
    }

    async function loadActiveGames() {
      console.log('Iniciando loadActiveGames()');
      try {
        const activeGamesRef = ref(database, 'activeGames');
        const snapshot = await get(activeGamesRef);
        activeGames = [];
        console.log('Snapshot recebido:', snapshot.exists());
        if (snapshot.exists()) {
          Object.entries(snapshot.val()).forEach(([id, game]) => {
            activeGames.push({
              id,
              date: game.date,
              time: game.time,
              playerLimit: game.playerLimit || 16,
              createdAt: game.createdAt
            });
          });
          activeGames.sort((a, b) => {
            const dateA = new Date(`${a.date}T${a.time}`);
            const dateB = new Date(`${b.date}T${b.time}`);
            return dateA - dateB;
          });
          console.log('Jogos ativos ordenados:', activeGames);
        }
        const gameSelect = document.getElementById('gameSelect');
        if (!gameSelect) {
          console.error('Elemento gameSelect n√£o encontrado no DOM');
          return;
        }
        gameSelect.innerHTML = '<option value="">Selecione um jogo</option>';
        if (activeGames.length === 0) {
          gameSelect.innerHTML = '<option value="">Nenhum jogo agendado</option>';
          console.log('Nenhum jogo agendado');
        } else {
          activeGames.forEach(game => {
            const option = document.createElement('option');
            option.value = game.id;
            const gameDateTime = DateTime.fromISO(`${game.date}T${game.time}`, { zone: 'America/Sao_Paulo' });
            const formattedDate = gameDateTime.toFormat('dd/MM/yyyy');
            const formattedTime = gameDateTime.toFormat('HH:mm');
            const dayNumber = gameDateTime.weekday;
            const dayOfWeek = customWeekdays[dayNumber] || gameDateTime.toFormat('EEEE');
            option.textContent = `${formattedDate} - ${formattedTime} (${dayOfWeek})`;
            if (game.id === currentGameId) {
              option.selected = true;
            }
            gameSelect.appendChild(option);
          });
          console.log('Op√ß√µes adicionadas ao gameSelect:', gameSelect.innerHTML);
        }
        gameSelect.addEventListener('change', async () => {
          console.log('GameSelect alterado, novo valor:', gameSelect.value);
          currentGameId = gameSelect.value;
          await loadGameData(currentGameId);
        });
        if (activeGames.length > 0 && !currentGameId) {
          currentGameId = activeGames[0].id;
          gameSelect.value = currentGameId;
          console.log('Jogo padr√£o selecionado:', currentGameId);
          await loadGameData(currentGameId);
        } else if (!activeGames.some(game => game.id === currentGameId)) {
          currentGameId = null;
          console.log('Nenhum jogo correspondente, carregando dados padr√£o');
          await loadGameData('current');
        }
      } catch (error) {
        console.error('Erro ao carregar jogos ativos:', error);
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'N√£o foi poss√≠vel carregar os jogos ativos.',
        });
      }
    }

    function setupPlayerSearch() {
      playerSearch.addEventListener('input', () => {
        const query = playerSearch.value.trim().toLowerCase();
        autocompleteSuggestions.innerHTML = '';
        selectedPlayerId = null;
        addPlayerBtn.disabled = true;
        if (query.length > 0) {
          const suggestions = allPlayers
            .filter(player => player.name?.toLowerCase().includes(query))
            .slice(0, 5);
          if (suggestions.length > 0) {
            suggestions.forEach(player => {
              const div = document.createElement('div');
              div.className = 'autocomplete-suggestion';
              div.textContent = `${player.name} (${player.category || 'CONVIDADO'})`;
              div.addEventListener('click', () => {
                playerSearch.value = player.name;
                selectedPlayerId = player.id;
                addPlayerBtn.disabled = false;
                autocompleteSuggestions.style.display = 'none';
              });
              autocompleteSuggestions.appendChild(div);
            });
            autocompleteSuggestions.style.display = 'block';
          } else {
            autocompleteSuggestions.style.display = 'none';
          }
        } else {
          autocompleteSuggestions.style.display = 'none';
        }
      });
      playerSearch.addEventListener('blur', () => {
        setTimeout(() => {
          autocompleteSuggestions.style.display = 'none';
        }, 200);
      });
      addPlayerBtn.addEventListener('click', () => {
        if (selectedPlayerId) {
          confirmPlayer(selectedPlayerId);
        }
      });
    }

    function setupGuestControls() {
      addGuestBtn.addEventListener('click', addGuest);
    }

    async function addGuest() {
      if (!window.currentUserPlayer) {
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Voc√™ precisa estar registrado como jogador para adicionar convidados.',
        });
        return;
      }
      if (!currentGameId) {
        await Swal.fire({
          icon: 'info',
          title: 'Que pena, nenhum jogo Programado!',
          text: 'Selecione um jogo ativo ou aguarde a abertura da lista.',
        });
        return;
      }
      const guestName = guestNameInput.value.trim();
      if (!guestName) {
        await Swal.fire({
          icon: 'error',
          title: 'Nome Inv√°lido',
          text: 'Por favor, insira o nome do convidado.',
        });
        return;
      }
      if (confirmedPlayers.some(p => p.name === guestName && p.category === 'CONVIDADO' && p.invitedById === window.currentUserPlayer.id) ||
          waitlistPlayers.some(p => p.name === guestName && p.category === 'CONVIDADO' && p.invitedById === window.currentUserPlayer.id)) {
        await Swal.fire({
          icon: 'warning',
          title: 'Convidado J√° Adicionado',
          text: 'Este convidado j√° foi adicionado para este jogo.',
        });
        return;
      }
      const result = await Swal.fire({
        icon: 'warning',
        title: 'Aten√ß√£o',
        html: `Voc√™ est√° convidando <strong>${guestName}</strong> e declara estar ciente de que √© devida uma "Taxa Convidado" de <strong>R$${guestFee.toFixed(2)}</strong> sendo a mesma inserida em seu registro para fins de transpar√™ncia e controle de todos.`,
        showCancelButton: true,
        confirmButtonText: 'Estou Ciente',
        cancelButtonText: 'Cancelar',
      });
      if (!result.isConfirmed) {
        guestNameInput.value = '';
        return;
      }
      try {
        const guestId = `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const guestObj = {
          id: guestId,
          name: guestName,
          category: 'CONVIDADO',
          position: '-',
          timestamp: getBrazilTimestamp(),
          paymentStatus: 'inadimplente',
          imageUrl: defaultImage,
          invitedById: window.currentUserPlayer.id,
          invitedByName: window.currentUserPlayer.name,
          status: 'pending',
          additionalInfo: guestName,
          createdAt: getBrazilDateTimeISO(),
          date: null,
          month: getBrazilMonthYear(),
          paymentType: 'CONVIDADO',
          value: parseFloat(guestFee.toFixed(2))
        };
        console.log(`Adicionando convidado com taxa: R$${guestObj.value}, ID: ${guestId}`);
        const [year, month] = getBrazilMonthYear().split('-');
        const paymentId = `payment_${guestId}_${currentGameId}_CONVIDADO_${Date.now()}`;
        const paymentRef = ref(database, `payments/${year}/${month}/${paymentId}`);
        await set(paymentRef, {
          additionalInfo: guestName,
          createdAt: getBrazilDateTimeISO(),
          month: getBrazilMonthYear(),
          paymentType: 'CONVIDADO',
          playerId: window.currentUserPlayer.id,
          playerName: window.currentUserPlayer.name,
          value: parseFloat(guestFee.toFixed(2)),
          gameId: currentGameId,
          date: null,
          paymentStatus: 'inadimplente',
          guestId: guestId,
          guestName: guestName
        });
        if (confirmedPlayers.length < playerLimit) {
          confirmedPlayers.push(guestObj);
        } else {
          const lowestPriorityPlayer = sortPlayers([...confirmedPlayers]).slice(-1)[0];
          if ((categoryPriority[guestObj.category] || 0) > (categoryPriority[lowestPriorityPlayer.category] || 0)) {
            confirmedPlayers = confirmedPlayers.filter(p => p.id !== lowestPriorityPlayer.id);
            waitlistPlayers.push(lowestPriorityPlayer);
            confirmedPlayers.push(guestObj);
          } else {
            waitlistPlayers.push(guestObj);
          }
        }
        confirmedPlayers = sortPlayers(confirmedPlayers);
        waitlistPlayers = sortPlayers(waitlistPlayers);
        await updateFirebaseLists();
        updateGameList();
        const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
        const playerName = window.currentUserPlayer?.name || 'usu√°rio n√£o identificado';
        const message = `Convidado ${guestName} adicionado ao jogo ${formattedDate} √†s ${currentGameData?.time || 'hor√°rio n√£o definido'} por ${playerName}.`;
        await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage, window.currentUserPlayer?.id);
        guestNameInput.value = '';
        await Swal.fire({
          icon: 'success',
          title: 'Sucesso',
          html: `
            Convidado adicionado, efetue o pagamento e comunique aos ADMs para aprova√ß√£o e registro da contribui√ß√£o.<br><br>
            PIX para pagamento: <strong>fabioluiztx@outlook.com</strong><br>
            <button id="copyPixBtn" class="swal2-confirm swal2-styled">Copiar PIX</button>
          `,
          showConfirmButton: false,
          didOpen: () => {
            const copyPixBtn = document.getElementById('copyPixBtn');
            copyPixBtn.addEventListener('click', async () => {
              try {
                await navigator.clipboard.writeText('fabioluiztx@outlook.com');
                await Swal.fire({
                  icon: 'success',
                  title: 'Copiado!',
                  text: 'Endere√ßo PIX copiado para a √°rea de transfer√™ncia.',
                  timer: 1500,
                  showConfirmButton: false
                });
                abrirQuadra();
              } catch (error) {
                console.error('Erro ao copiar PIX:', error);
                await Swal.fire({
                  icon: 'error',
                  title: 'Erro',
                  text: 'N√£o foi poss√≠vel copiar o endere√ßo PIX.',
                });
              }
            });
          }
        });
      } catch (error) {
        console.error('Erro ao adicionar convidado:', error);
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Erro ao adicionar convidado.',
        });
      }
    }

    async function findExistingPayment(playerId, gameId, paymentType, additionalInfo) {
      try {
        const paymentsRef = ref(database, 'payments');
        const snapshot = await get(paymentsRef);
        if (!snapshot.exists()) {
          return null;
        }
        const years = snapshot.val() || {};
        let matchingPayment = null;
        for (const year in years) {
          for (const month in years[year]) {
            const payments = years[year][month] || {};
            const playerPayments = Object.entries(payments)
              .map(([id, payment]) => ({
                paymentId: id,
                ...payment
              }))
              .filter(p => 
                p.playerId === playerId && 
                p.gameId === gameId && 
                p.paymentType === paymentType && 
                p.additionalInfo === additionalInfo
              );
            if (playerPayments.length > 0) {
              matchingPayment = playerPayments[0];
              matchingPayment.year = year;
              matchingPayment.month = month;
              break;
            }
          }
          if (matchingPayment) break;
        }
        return matchingPayment;
      } catch (error) {
        console.error('Erro ao buscar pagamento existente:', error);
        return null;
      }
    }

    async function approvePlayer(playerId, fromConfirmed = true, isPaid = true) {
      if (!isAdmin) {
        await Swal.fire({
          icon: 'error',
          title: 'Permiss√£o Negada',
          text: 'Voc√™ n√£o tem permiss√£o para aprovar jogadores.',
        });
        return;
      }
      if (!currentGameId) {
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Selecione um jogo ativo para aprovar jogadores.',
        });
        return;
      }
      try {
        const player = fromConfirmed
          ? confirmedPlayers.find(p => p.id === playerId)
          : waitlistPlayers.find(p => p.id === playerId);
        if (!player) {
          await Swal.fire({
            icon: 'warning',
            title: 'Jogador N√£o Encontrado',
            text: 'Jogador n√£o encontrado.',
          });
          return;
        }
        if (player.status !== 'approved') {
          player.status = 'approved';
        }
        player.paymentStatus = isPaid ? 'pago' : 'inadimplente';
        let paymentValue = parseFloat(guestFee.toFixed(2));
        if (isNaN(paymentValue) || paymentValue <= 0) {
          console.warn(`Valor inv√°lido para jogador ${player.name}: ${paymentValue}. Usando valor padr√£o: ${guestFee}`);
          paymentValue = parseFloat(guestFee.toFixed(2));
        }
        const paymentData = {
          additionalInfo: player.additionalInfo || player.name,
          createdAt: player.createdAt || getBrazilDateTimeISO(),
          month: player.month || getBrazilMonthYear(),
          paymentType: player.paymentType || (player.category === 'CONVIDADO' ? 'CONVIDADO' : 'DIARIA'),
          playerId: player.category === 'CONVIDADO' ? player.invitedById || player.id : player.id,
          playerName: player.category === 'CONVIDADO' ? player.invitedByName || player.name : player.name,
          value: paymentValue,
          gameId: currentGameId,
          date: isPaid ? (player.date || formatDateToISO(new Date())) : null,
          paymentStatus: player.paymentStatus,
          guestId: player.category === 'CONVIDADO' ? player.id : null,
          guestName: player.category === 'CONVIDADO' ? player.name : null
        };
        const existingPayment = await findExistingPayment(
          paymentData.playerId,
          currentGameId,
          paymentData.paymentType,
          paymentData.additionalInfo
        );
        const [year, month] = (paymentData.month || getBrazilMonthYear()).split('-');
        if (existingPayment) {
          console.log(`Atualizando pagamento existente para ${player.name}, ID: ${existingPayment.paymentId}`);
          const paymentRef = ref(database, `payments/${existingPayment.year}/${existingPayment.month}/${existingPayment.paymentId}`);
          await update(paymentRef, {
            paymentStatus: player.paymentStatus,
            date: paymentData.date,
            value: paymentValue,
            updatedAt: getBrazilDateTimeISO()
          });
        } else {
          console.log(`Criando novo pagamento para ${player.name}`);
          const paymentId = `payment_${player.id}_${currentGameId}_${paymentData.paymentType}_${Date.now()}`;
          const paymentRef = ref(database, `payments/${year}/${month}/${paymentId}`);
          await set(paymentRef, paymentData);
        }
        // Zerar contador de avisos ao aprovar como pago
        if (isPaid && player.category !== 'CONVIDADO') {
          await resetWarningCount(player.id);
        } else if (isPaid && player.category === 'CONVIDADO') {
          await resetWarningCount(player.invitedById);
        }
        await updateFirebaseLists();
        updateGameList();
        const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
        const statusText = isPaid ? 'Liberado (pago)' : 'Liberado (d√©bito)';
        const message = `${player.name} foi ${statusText} para o jogo ${formattedDate}.`;
        await sendPushNotification(message, window.currentUserPlayer?.imageUrl || defaultImage);
        await Swal.fire({
          icon: 'success',
          title: 'Sucesso',
          text: `Jogador marcado como ${isPaid ? 'pago' : 'devendo'} e registro atualizado.`,
        });
      } catch (error) {
        console.error('Erro ao aprovar jogador:', error);
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Erro ao processar aprova√ß√£o.',
        });
      }
    }



    async function confirmPlayer(targetPlayerId = null) {
  if (!currentGameId) {
    await Swal.fire({
      icon: 'info',
      title: 'Que pena, nenhum jogo Programado!',
      text: 'Selecione um jogo ativo ou aguarde a abertura da lista.',
    });
    return;
  }
  const isAdmin = adminEmails.includes(emailLogado);
  const playerId = isAdmin && targetPlayerId ? targetPlayerId : window.currentUserPlayer?.id;
  if (!playerId) {
    await Swal.fire({
      icon: 'error',
      title: 'Erro',
      text: 'Nenhum jogador selecionado ou associado a este email.',
    });
    return;
  }
  try {
    // Nova l√≥gica: Verificar pend√™ncias e avisos
    const warningResult = await handlePaymentWarnings(playerId, isAdmin, emailLogado);
    if (!warningResult.allowConfirmation) {
      return; // Bloqueia a confirma√ß√£o se houver pend√™ncias e limite de avisos atingido
    }

    const playerRef = ref(database, `players/${playerId}`);
    const playerSnapshot = await get(playerRef);
    if (!playerSnapshot.exists()) {
      await Swal.fire({
        icon: 'error',
        title: 'Jogador N√£o Encontrado',
        text: 'Jogador n√£o encontrado.',
      });
      return;
    }
    const playerData = playerSnapshot.val();
    const playerObj = {
      id: playerId,
      name: playerData.name || '-',
      category: playerData.category || 'CONVIDADO',
      position: playerData.position || '-',
      timestamp: getBrazilTimestamp(),
      paymentStatus: playerData.category === 'DIARIA' ? 'inadimplente' : await checkPaymentStatus(playerId),
      imageUrl: playerData.imageUrl || defaultImage,
      status: playerData.category === 'CONVIDADO' || playerData.category === 'DIARIA' ? 'pending' : null,
      additionalInfo: playerData.name || null,
      createdAt: getBrazilDateTimeISO(),
      date: null,
      month: getBrazilMonthYear(),
      paymentType: playerData.category === 'DIARIA' || playerData.category === 'CONVIDADO' ? playerData.category : null,
      value: playerData.category === 'DIARIA' || playerData.category === 'CONVIDADO' ? parseFloat(guestFee.toFixed(2)) : null
    };
    if (confirmedPlayers.some(p => p.id === playerId) || waitlistPlayers.some(p => p.id === playerId)) {
      await Swal.fire({
        icon: 'warning',
        title: 'Presen√ßa J√° Confirmada',
        text: 'Voc√™ j√° confirmou sua presen√ßa.',
      });
      abrirQuadra();
      return;
    }
    if (playerObj.category === 'DIARIA') {
      const result = await Swal.fire({
        icon: 'warning',
        title: 'Aten√ß√£o',
        html: `<strong>${playerObj.name}</strong>, voc√™ declara estar ciente de que √© devida uma taxa di√°ria de <strong>R$${guestFee.toFixed(2)}</strong>, sendo a mesma inserida em seu registro para fins de transpar√™ncia e controle de todos.`,
        showCancelButton: true,
        confirmButtonText: 'Estou Ciente',
        cancelButtonText: 'Cancelar',
      });
      if (!result.isConfirmed) {
        return;
      }
    }
    if (playerObj.category === 'DIARIA') {
      const [year, month] = getBrazilMonthYear().split('-');
      const paymentId = `payment_${playerId}_${currentGameId}_DIARIA_${Date.now()}`;
      const paymentRef = ref(database, `payments/${year}/${month}/${paymentId}`);
      await set(paymentRef, {
        additionalInfo: playerObj.name,
        createdAt: getBrazilDateTimeISO(),
        month: getBrazilMonthYear(),
        paymentType: 'DIARIA',
        playerId: playerId,
        playerName: playerObj.name,
        value: parseFloat(guestFee.toFixed(2)),
        gameId: currentGameId,
        date: null,
        paymentStatus: 'inadimplente'
      });
    }
    if (confirmedPlayers.length < playerLimit) {
      confirmedPlayers.push(playerObj);
    } else {
      const lowestPriorityPlayer = sortPlayers([...confirmedPlayers]).slice(-1)[0];
      if ((categoryPriority[playerObj.category] || 0) > (categoryPriority[lowestPriorityPlayer.category] || 0)) {
        confirmedPlayers = confirmedPlayers.filter(p => p.id !== lowestPriorityPlayer.id);
        waitlistPlayers.push(lowestPriorityPlayer);
        confirmedPlayers.push(playerObj);
      } else {
        waitlistPlayers.push(playerObj);
      }
    }
    confirmedPlayers = sortPlayers(confirmedPlayers);
    waitlistPlayers = sortPlayers(waitlistPlayers);
    await updateFirebaseLists();
    updateGameList();
    const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
    const message = `${playerObj.name} confirmou presen√ßa para o jogo ${formattedDate} √†s ${currentGameData?.time || 'hor√°rio n√£o definido'}.`;
    await sendPushNotification(message, playerObj.imageUrl || defaultImage);
    if (playerObj.category === 'DIARIA') {
      await Swal.fire({
        icon: 'success',
        title: 'Sucesso',
        html: `
          Confirma√ß√£o lan√ßada com sucesso, aguarde aprova√ß√£o dos ADMs para registro da contribui√ß√£o e disponibilidade de Vaga.<br><br>
          PIX para pagamento: <strong>fabioluiztx@outlook.com</strong><br>
          <button id="copyPixBtn" class="swal2-confirm swal2-styled">Copiar PIX</button>
        `,
        showConfirmButton: false,
        didOpen: () => {
          const copyPixBtn = document.getElementById('copyPixBtn');
          copyPixBtn.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText('fabioluiztx@outlook.com');
              await Swal.fire({
                icon: 'success',
                title: 'Copiado!',
                text: 'Endere√ßo PIX copiado para a √°rea de transfer√™ncia.',
                timer: 1500,
                showConfirmButton: false
              });
            } catch (error) {
              console.error('Erro ao copiar PIX:', error);
              await Swal.fire({
                icon: 'error',
                title: 'Erro',
                text: 'N√£o foi poss√≠vel copiar o endere√ßo PIX.',
              });
            }
          });
        }
      });
    }
    if (isAdmin && targetPlayerId) {
      playerSearch.value = '';
      selectedPlayerId = null;
      addPlayerBtn.disabled = true;
      autocompleteSuggestions.style.display = 'none';
    }
    abrirQuadra();
  } catch (error) {
    console.error('Erro ao confirmar jogador:', error);
    await Swal.fire({
      icon: 'error',
      title: 'Erro',
      text: 'Erro ao processar confirma√ß√£o.',
    });
  }
}




    async function updateFirebaseLists() {
      if (!currentGameId) return;
      try {
        const gameRef = ref(database, `activeGames/${currentGameId}`);
        const confirmed = {};
        const waitlist = {};
        confirmedPlayers.forEach(player => {
          confirmed[player.id] = player;
        });
        waitlistPlayers.forEach(player => {
          waitlist[player.id] = player;
        });
        await update(gameRef, {
          confirmed,
          waitlist
        });
      } catch (error) {
        console.error('Erro ao atualizar listas no Firebase:', error);
      }
    }

    async function checkPaymentStatus(playerId) {
      try {
        const pendingPayments = await checkPendingPayments(playerId);
        return pendingPayments.length > 0 ? 'inadimplente' : 'pago';
      } catch (error) {
        console.error('Erro ao verificar status de pagamento:', error);
        return 'inadimplente';
      }
    }

    async function sendPushNotification(message, imageUrl, playerId = null) {
      try {
        const notificationRef = ref(database, 'notifications');
        const newNotificationRef = push(notificationRef);
        await set(newNotificationRef, {
          message,
          imageUrl: imageUrl || defaultImage,
          timestamp: getBrazilDateTimeISO(),
          playerId: playerId || null
        });
      } catch (error) {
        console.error('Erro ao enviar notifica√ß√£o:', error);
      }
    }

    function updateGameList() {
      confirmedPlayersDiv.innerHTML = '';
      waitlistPlayersDiv.innerHTML = '';
      if (confirmedPlayers.length === 0) {
        confirmedPlayersDiv.innerHTML = '<p>Nenhum jogador confirmado.</p>';
      } else {
        confirmedPlayers.forEach(player => {
          const playerDiv = document.createElement('div');
          playerDiv.className = 'player-item';
          const statusIcon = player.status === 'approved'
            ? '<i class="fas fa-check-circle" style="color: green;"></i>'
            : player.status === 'pending'
              ? '<i class="fas fa-hourglass-half" style="color: orange;"></i>'
              : '';
          const paymentIcon = player.paymentStatus === 'pago'
            ? '<i class="fas fa-money-check-alt" style="color: green;"></i>'
            : '<i class="fas fa-exclamation-triangle" style="color: red;"></i>';
          let playerInfo = `${player.name} (${player.category})`;
          if (player.category === 'CONVIDADO') {
            playerInfo += ` - Convidado por ${player.invitedByName || 'Desconhecido'}`;
          }
          playerDiv.innerHTML = `
            <img src="${player.imageUrl}" alt="${player.name}" class="player-photo" onerror="this.src='${defaultImage}'">
            <span>${playerInfo} ${statusIcon} ${paymentIcon}</span>
          `;
          if (isAdmin || (window.currentUserPlayer && player.id === window.currentUserPlayer.id)) {
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
            removeBtn.addEventListener('click', () => removePlayer(player.id, true));
            playerDiv.appendChild(removeBtn);
          }
          if (isAdmin && (player.status !== 'approved' || player.paymentStatus !== 'pago')) {
            const actionBtn = document.createElement('button');
            actionBtn.className = 'action-btn';
            actionBtn.innerHTML = '<i class="fas fa-cog"></i>';
            actionBtn.addEventListener('click', () => showPlayerActions(player));
            playerDiv.appendChild(actionBtn);
          }
          confirmedPlayersDiv.appendChild(playerDiv);
        });
      }
      if (waitlistPlayers.length === 0) {
        waitlistPlayersDiv.innerHTML = '<p>Nenhum jogador na lista de espera.</p>';
      } else {
        waitlistPlayers.forEach(player => {
          const playerDiv = document.createElement('div');
          playerDiv.className = 'player-item';
          const statusIcon = player.status === 'approved'
            ? '<i class="fas fa-check-circle" style="color: green;"></i>'
            : player.status === 'pending'
              ? '<i class="fas fa-hourglass-half" style="color: orange;"></i>'
              : '';
          const paymentIcon = player.paymentStatus === 'pago'
            ? '<i class="fas fa-money-check-alt" style="color: green;"></i>'
            : '<i class="fas fa-exclamation-triangle" style="color: red;"></i>';
          let playerInfo = `${player.name} (${player.category})`;
          if (player.category === 'CONVIDADO') {
            playerInfo += ` - Convidado por ${player.invitedByName || 'Desconhecido'}`;
          }
          playerDiv.innerHTML = `
            <img src="${player.imageUrl}" alt="${player.name}" class="player-photo" onerror="this.src='${defaultImage}'">
            <span>${playerInfo} ${statusIcon} ${paymentIcon}</span>
          `;
          if (isAdmin || (window.currentUserPlayer && player.id === window.currentUserPlayer.id)) {
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
            removeBtn.addEventListener('click', () => removePlayer(player.id, false));
            playerDiv.appendChild(removeBtn);
          }
          if (isAdmin && (player.status !== 'approved' || player.paymentStatus !== 'pago')) {
            const actionBtn = document.createElement('button');
            actionBtn.className = 'action-btn';
            actionBtn.innerHTML = '<i class="fas fa-cog"></i>';
            actionBtn.addEventListener('click', () => showPlayerActions(player));
            playerDiv.appendChild(actionBtn);
          }
          waitlistPlayersDiv.appendChild(playerDiv);
        });
      }
      updatePlayerLimitDisplay(isAdmin);
    }

    function updatePlayerLimitDisplay(isAdmin) {
      const limitDisplay = document.createElement('div');
      limitDisplay.className = 'player-limit';
      limitDisplay.textContent = `Limite: ${confirmedPlayers.length}/${playerLimit}`;
      if (confirmedPlayersDiv.parentElement.querySelector('.player-limit')) {
        confirmedPlayersDiv.parentElement.querySelector('.player-limit').replaceWith(limitDisplay);
      } else {
        confirmedPlayersDiv.parentElement.insertBefore(limitDisplay, confirmedPlayersDiv);
      }
    }

    async function adjustConfirmedPlayers() {
      if (confirmedPlayers.length > playerLimit) {
        const sortedPlayers = sortPlayers([...confirmedPlayers]);
        const excessPlayers = sortedPlayers.slice(playerLimit);
        confirmedPlayers = sortedPlayers.slice(0, playerLimit);
        waitlistPlayers = [...waitlistPlayers, ...excessPlayers];
        waitlistPlayers = sortPlayers(waitlistPlayers);
      }
    }

    async function removePlayer(playerId, fromConfirmed = true) {
      let player;
      if (fromConfirmed) {
        player = confirmedPlayers.find(p => p.id === playerId);
        confirmedPlayers = confirmedPlayers.filter(p => p.id !== playerId);
      } else {
        player = waitlistPlayers.find(p => p.id === playerId);
        waitlistPlayers = waitlistPlayers.filter(p => p.id !== playerId);
      }
      if (!player) {
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'Jogador n√£o encontrado.',
        });
        return;
      }
      if (player.category === 'CONVIDADO' || player.category === 'DIARIA') {
        const payment = await findExistingPayment(
          player.category === 'CONVIDADO' ? player.invitedById : player.id,
          currentGameId,
          player.category,
          player.name
        );
        if (payment) {
          const paymentRef = ref(database, `payments/${payment.year}/${payment.month}/${payment.paymentId}`);
          await remove(paymentRef);
        }
      }
      if (waitlistPlayers.length > 0 && confirmedPlayers.length < playerLimit) {
        const topWaitlistPlayer = sortPlayers([...waitlistPlayers])[0];
        waitlistPlayers = waitlistPlayers.filter(p => p.id !== topWaitlistPlayer.id);
        confirmedPlayers.push(topWaitlistPlayer);
        confirmedPlayers = sortPlayers(confirmedPlayers);
        const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
        const message = `${topWaitlistPlayer.name} subiu da lista de espera para a lista confirmada do jogo ${formattedDate}.`;
        await sendPushNotification(message, topWaitlistPlayer.imageUrl || defaultImage);
      }
      await updateFirebaseLists();
      updateGameList();
      const formattedDate = currentGameData ? formatDateToBR(currentGameData.date) : 'data n√£o definida';
      const message = `${player.name} foi removido do jogo ${formattedDate}.`;
      await sendPushNotification(message, player.imageUrl || defaultImage);
    }

    async function showPlayerActions(player) {
      const isGuest = player.category === 'CONVIDADO';
      const playerName = isGuest ? `${player.name} (Convidado por ${player.invitedByName})` : player.name;
      const result = await Swal.fire({
        title: `A√ß√µes para ${playerName}`,
        html: `
          <div class="organiza">
            <button id="approvePaidBtn" class="swal2-styled">Aprovar como Pago</button>
            <button id="approveUnpaidBtn" class="swal2-styled">Aprovar sem Pagamento</button>
            <button id="removePlayerBtn" class="swal2-styled swal2-cancel">Remover Jogador</button>
          </div>
        `,
        showConfirmButton: false,
        showCancelButton: true,
        cancelButtonText: 'Cancelar',
        didOpen: () => {
          document.getElementById('approvePaidBtn').addEventListener('click', () => {
            approvePlayer(player.id, confirmedPlayers.some(p => p.id === player.id), true);
            Swal.close();
          });
          document.getElementById('approveUnpaidBtn').addEventListener('click', () => {
            approvePlayer(player.id, confirmedPlayers.some(p => p.id === player.id), false);
            Swal.close();
          });
          document.getElementById('removePlayerBtn').addEventListener('click', () => {
            removePlayer(player.id, confirmedPlayers.some(p => p.id === player.id));
            Swal.close();
          });
        }
      });
    }

    async function loadGameData(gameId) {
      console.log('Carregando dados do jogo:', gameId);
      if (!gameId) {
        console.log('Nenhum jogo selecionado');
        currentGameData = null;
        confirmedPlayers = [];
        waitlistPlayers = [];
        updateGameDateDisplay();
        updateGameList();
        return;
      }
      try {
        const gameRef = ref(database, `activeGames/${gameId}`);
        const snapshot = await get(gameRef);
        if (snapshot.exists()) {
          currentGameData = snapshot.val();
          playerLimit = currentGameData.playerLimit || 16;
          confirmedPlayers = Object.values(currentGameData.confirmed || {});
          waitlistPlayers = Object.values(currentGameData.waitlist || {});
          confirmedPlayers = sortPlayers(confirmedPlayers);
          waitlistPlayers = sortPlayers(waitlistPlayers);
          updateGameDateDisplay();
          updateGameList();
          console.log('Dados do jogo carregados:', currentGameData);
        } else {
          console.log('Jogo n√£o encontrado, limpando dados');
          currentGameData = null;
          confirmedPlayers = [];
          waitlistPlayers = [];
          updateGameDateDisplay();
          updateGameList();
        }
      } catch (error) {
        console.error('Erro ao carregar dados do jogo:', error);
        await Swal.fire({
          icon: 'error',
          title: 'Erro',
          text: 'N√£o foi poss√≠vel carregar os dados do jogo.',
        });
      }
    }

    async function abrirQuadra() {
      if (!currentGameId) {
        await Swal.fire({
          icon: 'info',
          title: 'Que pena, nenhum jogo Programado!',
          text: 'Selecione um jogo ativo ou aguarde a abertura da lista.',
        });
        return;
      }
      confirmPlayer();
    }

    // Estilos CSS inline para o modal e listas
    const style = document.createElement('style');
    style.textContent = `
      .organiza {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
      .organiza2 {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }
      .modal-section {
        margin-bottom: 20px;
        text-align: left;
      }
      .swal2-html-container ul {
        list-style-type: disc;
        padding-left: 20px;
        margin-top: 10px;
        text-align: left;
      }
      .player-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        border-bottom: 1px solid #ddd;
      }
      .autocomplete-suggestions {
        position: absolute;
        background: white;
        border: 1px solid #ddd;
        max-height: 150px;
        overflow-y: auto;
        width: 100%;
        z-index: 1000;
      }
      .autocomplete-suggestion {
        padding: 10px;
        cursor: pointer;
      }
      .autocomplete-suggestion:hover {
        background: #f0f0f0;
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
